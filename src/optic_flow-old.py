#!/usr/bin/env python2
from __future__ import division
import numpy as np
from sensor_msgs.msg import CameraInfo
from camera import Camera
import rospy

NODE_NAME = 'optic_flow'

class OpticFlow():

    def __init__(self):
        self.cam = None
        self.axis_0 = (1, 0, 0)
        self.axis_45 = (1/np.sqrt(2), -1/np.sqrt(2), 0)
        self.axis_n45 = (1/np.sqrt(2), 1/np.sqrt(2), 0)
        self.filters = None

    def rotation_matrix_from_rpy_degs(self, yaw=0.0, pitch=0.0, roll=0.0):
        """
        In camera coordinates
          x - pitch
          y - roll
          z yaw
        """
        rx = np.deg2rad(pitch)
        ry = np.deg2rad(roll)
        rz = np.deg2rad(yaw)

        Rx = np.array([[1, 0, 0], [0, np.cos(rx), -np.sin(rx)],
                       [0, np.sin(rx), np.cos(rx)]])
        Ry = np.array([[np.cos(ry), 0, np.sin(ry)], [0, 1, 0],
                       [-np.sin(ry), 0, np.cos(ry)]])
        Rz = np.array([[np.cos(rz), -np.sin(rz), 0],
                       [np.sin(rz), np.cos(rz), 0], [0, 0, 1]])

        rot_mat = np.matmul(Rx, Rz)
        return rot_mat

    def rotate_viewing_directions(self, D, yaw=0.0, pitch=0.0, roll=0.0):
        rot_mat = self.rotation_matrix_from_rpy_degs(yaw=yaw,
                                                     pitch=pitch,
                                                     roll=roll)
        for ii in range(self.cam.h):
            for jj in range(self.cam.w):
                D[ii, jj, :] = np.matmul(D[ii, jj, :], rot_mat)
        return D

    def _get_anticipated_viewing_directions(self):
        vertical_views = (((np.arange(self.cam.h, dtype=float) -
                            self.cam.h / 2.0) / float(self.cam.h)) *
                          self.cam.fovy)
        horizontal_views = (((np.arange(self.cam.w, dtype=float) -
                              self.cam.w / 2.0) / float(self.cam.w)) *
                            self.cam.fovx)
        D = -np.ones([self.cam.h, self.cam.w, 3])
        D[:, :, 0], D[:, :, 1] = np.meshgrid(np.tan(horizontal_views),
                                                 np.tan(vertical_views))
         
        return [self.rotate_viewing_directions(D, yaw=a)
                for a in [0, 45, -45]]
    
    def camera_params_cb(self, camera_info):
        #if self.filters == None:
        if not self.cam:
            self.cam = Camera(camera_info)  # Initialise a camera object
        # D_0, D_45, D_n45 = self._get_anticipated_viewing_directions()
        Ds = self._get_anticipated_viewing_directions()
        filters = []
        for D in Ds:
            # The small constant is to prevent a divide by zero
            sin_theta = np.linalg.norm(D[:, :, 0:2], axis=2) + 1e-14
            mag_temp = np.linalg.norm(D, axis=2)
            D /= np.expand_dims(mag_temp, axis=2)
            filters.append(sin_theta.reshape(self.cam.h,
                                                 self.cam.w, 1))
        self.filters = filters
        rospy.loginfo(self.filters)

    def plot_filters(self):
        """
        Plot the matched filters that have been generated by this class
        :return:
        """
        import matplotlib.pyplot as plt
        Y = ((np.arange(self.cam.h, dtype=float) - self.cam.h / 2.0) / float(
            self.cam.h)) * self.cam.fovy
        X = ((np.arange(self.cam.w, dtype=float) - self.cam.w / 2.0) / float(
            self.cam.w)) * self.cam.fovx
        U = self.filters[0][:, :, 0]
        V = self.filters[0][:, :, 1]

        plt.quiver(X, Y, U, V)
        plt.show()

    def main(self):
        rospy.Subscriber("/cam_0/camera_info", CameraInfo,
                         self.camera_params_cb)
        rate = rospy.Rate(10)
        while not rospy.is_shutdown():
            rate.sleep()

if __name__ == '__main__':
    rospy.init_node(NODE_NAME, anonymous=True, log_level=rospy.DEBUG)
    of = OpticFlow()
    of.main()
